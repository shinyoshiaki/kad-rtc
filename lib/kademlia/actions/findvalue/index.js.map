{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/kademlia/actions/findvalue/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { FindValueResult, OfferPayload } from \"./listen/node\";\n\nimport { DependencyInjection } from \"../../di\";\nimport { Item } from \"../../modules/kvs/base\";\nimport { Peer } from \"../../modules/peer/base\";\nimport { Signal } from \"webrtc4me\";\nimport { listeners } from \"../../listeners\";\n\nexport default async function findValue(\n  key: string,\n  di: DependencyInjection,\n  opt?: { preferTimeout?: number }\n): Promise<{ item: Item; peer: Peer } | undefined> {\n  const { kTable, rpcManager, signaling } = di;\n  let { timeout } = di.opt;\n  if (opt && opt.preferTimeout) timeout = opt.preferTimeout;\n\n  let result: { item: Item; peer: Peer } | undefined;\n\n  const job = async () => {\n    const findValueResultResult = await Promise.all(\n      kTable.allPeers.map(async proxy => {\n        const except = kTable.findNode(key).map(({ kid }) => kid);\n\n        const res = await rpcManager\n          .getWait<FindValueResult>(\n            proxy,\n            FindValue(key, except)\n          )(timeout)\n          .catch(() => {});\n\n        if (res) {\n          const { item, offers } = res.value;\n\n          if (item && !result) {\n            result = { item, peer: proxy };\n            return { offers: [], proxy };\n          } else if (offers) {\n            if (offers.length > 0) {\n              return { offers, proxy };\n            }\n          }\n        } else {\n          console.log(\"timeout\", proxy.type, timeout);\n        }\n\n        return { offers: [], proxy };\n      })\n    );\n\n    if (result) return;\n\n    const findValueAnswer = async (offer: OfferPayload, proxy: Peer) => {\n      const { peerKid, sdp } = offer;\n      const { peer, candidate } = signaling.create(peerKid);\n\n      const _createAnswer = async (peer: Peer) => {\n        const answer = await peer.setOffer(sdp);\n\n        rpcManager.run(proxy, FindValueAnswer(answer, peerKid));\n\n        const err = await peer.onConnect.asPromise(timeout).catch(() => {\n          return \"err\";\n        });\n        if (err) {\n          signaling.delete(peerKid);\n        } else {\n          listeners(peer, di);\n        }\n      };\n\n      if (peer) {\n        await _createAnswer(peer);\n      } else if (candidate) {\n        const { peer, event } = candidate;\n        // node.ts側でタイミング悪くPeerを作ってしまった場合の処理\n        // (並行テスト時にしか起きないと思う)\n        if (peer.SdpType === \"offer\") {\n          await _createAnswer(peer);\n        } else {\n          await event.asPromise(timeout).catch(() => {});\n        }\n      }\n      // 相手側のlistenが完了するまで待つ\n      // TODO : ちゃんと実装する\n      await new Promise(r => setTimeout(r, 100));\n    };\n\n    await Promise.all(\n      findValueResultResult\n        .map(v => v.offers.map(offer => findValueAnswer(offer, v.proxy)))\n        .flatMap(v => v)\n    );\n  };\n\n  for (\n    let preHash = \"\";\n    preHash !== kTable.getHash(key);\n    preHash = kTable.getHash(key)\n  ) {\n    await job();\n    if (result) break;\n  }\n\n  return result;\n}\n\nconst FindValue = (key: string, except: string[]) => ({\n  type: \"FindValue\" as const,\n  key,\n  except\n});\n\nexport type FindValue = ReturnType<typeof FindValue>;\n\nconst FindValueAnswer = (sdp: Signal, peerKid: string) => ({\n  type: \"FindValueAnswer\" as const,\n  sdp,\n  peerKid\n});\n\nexport type FindValueAnswer = ReturnType<typeof FindValueAnswer>;\n"]}