{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/kademlia/actions/findnode/index.ts"],"names":[],"mappings":";;;AAGA,8DAAsC;AAEtC,MAAM,QAAQ,GAAG,CAAC,SAAiB,EAAE,MAAgB,EAAE,EAAE;IACvD,OAAO,EAAE,GAAG,EAAE,UAAmB,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC;AACzD,CAAC,CAAC;AAIF,MAAM,cAAc,GAAG,CAAC,GAAW,EAAE,OAAe,EAAE,EAAE;IACtD,OAAO,EAAE,GAAG,EAAE,gBAAyB,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC;AAC1D,CAAC,CAAC;AAMF,SAA8B,QAAQ,CACpC,MAA6B,EAC7B,SAAiB,EACjB,MAAc;;QAEd,KAAK,IAAI,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC3C,MAAM,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACrD,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;YAElD,MAAM,GAAG,GAAY,MAAM,GAAG,CAAC,SAAS,EAAE,CAAC;YAC3C,IAAI,GAAG,CAAC,GAAG,KAAK,oBAAoB,EAAE;gBACpC,MAAM,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC;gBACzB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC;oBAAE,SAAS;gBAElC,KAAK,IAAI,KAAK,IAAI,MAAM,EAAE;oBACxB,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,KAAK,CAAC;oBAC/B,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;oBAChC,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;oBAE3C,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;oBAC1C,MAAM,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC;oBAEpC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;oBACpB,gBAAc,CAAC,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;iBACzC;aACF;SACF;QACD,OAAO,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;CAAA;AA5BD,2BA4BC","sourcesContent":["import Peer from \"../../modules/peer\";\nimport { FindNodeProxyOffer } from \"./listen/proxy\";\nimport Ktable from \"../../ktable\";\nimport listenFindnode from \"./listen\";\n\nconst FindNode = (searchkid: string, except: string[]) => {\n  return { rpc: \"findnode\" as const, searchkid, except };\n};\n\nexport type FindNode = ReturnType<typeof FindNode>;\n\nconst FindNodeAnswer = (sdp: string, peerkid: string) => {\n  return { rpc: \"findnodeanswer\" as const, sdp, peerkid };\n};\n\nexport type FindNodeAnswer = ReturnType<typeof FindNodeAnswer>;\n\ntype actions = FindNodeProxyOffer;\n\nexport default async function findNode(\n  module: (kid: string) => Peer,\n  searchkid: string,\n  ktable: Ktable\n) {\n  for (let peer of ktable.findNode(searchkid)) {\n    const except = ktable.allPeers.map(item => item.kid);\n    const rpc = peer.rpc(FindNode(searchkid, except));\n\n    const res: actions = await rpc.asPromise();\n    if (res.rpc === \"FindNodeProxyOffer\") {\n      const offers = res.peers;\n      if (offers.length === 0) continue;\n\n      for (let offer of offers) {\n        const { peerkid, sdp } = offer;\n        const connect = module(peerkid);\n        const answer = await connect.setOffer(sdp);\n\n        peer.rpc(FindNodeAnswer(answer, peerkid));\n        await connect.onConnect.asPromise();\n\n        ktable.add(connect);\n        listenFindnode(module, connect, ktable);\n      }\n    }\n  }\n  return ktable.getPeer(searchkid);\n}\n"]}