{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/kademlia/actions/findnode/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  FindNodeProxyAnswerError,\n  FindNodeProxyOffer,\n  OfferPayload\n} from \"./listen/node\";\n\nimport { DependencyInjection } from \"../../di\";\nimport { Peer } from \"../../modules/peer/base\";\nimport { Signal } from \"webrtc4me\";\nimport { listeners } from \"../../listeners\";\n\nexport default async function findNode(\n  searchKid: string,\n  di: DependencyInjection\n) {\n  const connected: Peer[] = [];\n  const { kTable, rpcManager, signaling } = di;\n  const { timeout } = di.opt;\n\n  if (kTable.getPeer(searchKid)) return [kTable.getPeer(searchKid)!];\n\n  const findNodeProxyOfferResult = await Promise.all(\n    kTable.findNode(searchKid).map(async peer => {\n      const except = kTable.allPeers.map(item => item.kid);\n\n      const res = await rpcManager\n        .getWait<FindNodeProxyOffer>(\n          peer,\n          FindNode(searchKid, except)\n        )(timeout)\n        .catch(() => {});\n\n      if (res) {\n        const { peers } = res;\n        if (peers.length > 0) return { peers, peer };\n      } else {\n        console.log(\"timeout\", timeout, peer.type);\n      }\n\n      return { peers: [], peer };\n    })\n  );\n\n  const _findNodeAnswer = async (node: Peer, offer: OfferPayload) => {\n    const { peerKid, sdp } = offer;\n    const { peer, candidate } = signaling.create(peerKid);\n    const __createAnswer = async (peer: Peer) => {\n      const answer = await peer.setOffer(sdp);\n\n      rpcManager\n        .asObservable<FindNodeProxyAnswerError>(\n          \"FindNodeProxyAnswerError\",\n          node\n        )\n        .once(() => {\n          peer.onConnect.error(\"FindNodeProxyAnswerError\");\n        });\n\n      rpcManager.run(node, FindNodeAnswer(answer, peerKid));\n\n      const err = await peer.onConnect.asPromise(timeout).catch(() => {\n        return \"err\";\n      });\n      if (err) {\n        signaling.delete(peerKid);\n      } else {\n        listeners(peer, di);\n        connected.push(peer);\n      }\n    };\n    if (peer) {\n      await __createAnswer(peer);\n    } else if (candidate) {\n      const { peer, event } = candidate;\n      // node.ts側でタイミング悪くPeerを作ってしまった場合の処理\n      // (並行テスト時にしか起きないと思う)\n      if (peer.SdpType === \"offer\") {\n        await __createAnswer(peer);\n      } else {\n        await event.asPromise(timeout).catch(() => {});\n      }\n    }\n    // 相手側のlistenが完了するまで待つ\n    // TODO : ちゃんと実装する\n    await new Promise(r => setTimeout(r, 100));\n  };\n\n  await Promise.all(\n    findNodeProxyOfferResult\n      .map(item => item.peers.map(offer => _findNodeAnswer(item.peer, offer)))\n      .flatMap(v => v)\n  );\n\n  return connected;\n}\n\nconst FindNode = (searchKid: string, except: string[]) => ({\n  type: \"FindNode\" as const,\n  searchKid,\n  except\n});\n\nexport type FindNode = ReturnType<typeof FindNode>;\n\nconst FindNodeAnswer = (sdp: Signal, peerKid: string) => ({\n  type: \"FindNodeAnswer\" as const,\n  sdp,\n  peerKid\n});\n\nexport type FindNodeAnswer = ReturnType<typeof FindNodeAnswer>;\n"]}