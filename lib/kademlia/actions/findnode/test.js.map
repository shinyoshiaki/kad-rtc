{"version":3,"file":"test.js","sourceRoot":"","sources":["../../../../src/kademlia/actions/findnode/test.ts"],"names":[],"mappings":";;;AACA,iDAAyB;AACzB,wDAA0D;AAE1D,MAAM,WAAW,GAAG,CAAC,CAAC;AACtB,MAAM,GAAG,GAAG,EAAE,CAAC;AAEf,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE;IACxB,IAAI,CACF,UAAU,EACV,GAAS,EAAE;QACT,MAAM,KAAK,GAAG,MAAM,0BAAc,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;QAErD,MAAM,MAAM,GAAG,CAAO,IAAY,EAAE,EAAE;YACpC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAEtB,IAAI,MAAwB,CAAC;YAE7B,IAAI,GAAG,GAAG,EAAE,EACV,OAAO,GAAG,CAAC,CAAC;YACd,OAEE,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EACjC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,EAC1C;gBACA,MAAM,GAAG,MAAM,UAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAEpC,IAAI,MAAM,EAAE;oBACV,MAAM;iBACP;aACF;YAED,IAAI,CAAC,MAAM,EAAE;gBACX,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACtC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aACvB;iBAAM;gBACL,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACpC;QACH,CAAC,CAAA,CAAC;QAEF,KAAK,IAAI,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YAC/B,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SAC/B;QAED,MAAM,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAEzC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CACnB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CACxD,CAAC;IACJ,CAAC,CAAA,EACD,IAAI,GAAG,IAAI,CACZ,CAAC;AACJ,CAAC,CAAC,CAAC","sourcesContent":["import { Peer } from \"../../modules/peer/base\";\nimport findNode from \".\";\nimport { testSetupNodes } from \"../../../utill/testtools\";\n\nconst kBucketSize = 8;\nconst num = 10;\n\ndescribe(\"findnode\", () => {\n  test(\n    \"findnode\",\n    async () => {\n      const nodes = await testSetupNodes(kBucketSize, num);\n\n      const search = async (word: string) => {\n        const node = nodes[0];\n\n        let target: undefined | Peer;\n\n        let pre = \"\",\n          trytime = 0;\n        for (\n          ;\n          pre !== node.kTable.getHash(word);\n          pre = node.kTable.getHash(word), trytime++\n        ) {\n          target = await findNode(word, node);\n\n          if (target) {\n            break;\n          }\n        }\n\n        if (!target) {\n          const now = node.kTable.getHash(word);\n          expect(pre).toBe(now);\n        } else {\n          expect(target).not.toBe(undefined);\n        }\n      };\n\n      for (let word of nodes.slice(1)) {\n        await search(word.kTable.kid);\n      }\n\n      await new Promise(r => setTimeout(r, 0));\n\n      nodes.forEach(node =>\n        node.kTable.allPeers.forEach(peer => peer.disconnect())\n      );\n    },\n    1000 * 6000\n  );\n});\n"]}