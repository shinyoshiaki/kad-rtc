{"version":3,"file":"file.js","sourceRoot":"","sources":["../../../src/webrtc/modules/file.ts"],"names":[],"mappings":"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","sourcesContent":["import WebRTC from \"../core\";\nimport { Subject, Observable } from \"rxjs\";\n\nconst chunkSize = 16000;\n\nexport function getSliceArrayBuffer(blob: Blob): Observable<any> {\n  const subject = new Subject<Actions>();\n  const state = subject.asObservable();\n\n  const r = new FileReader(),\n    blobSlice = File.prototype.slice,\n    chunks = Math.ceil(blob.size / chunkSize);\n  let currentChunk = 0;\n  r.onerror = e => {\n    subject.error(e);\n  };\n  r.onload = e => {\n    const chunk = (e.target as any).result;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      loadNext();\n      subject.next(chunk);\n    } else {\n      subject.complete();\n    }\n  };\n  function loadNext() {\n    const start = currentChunk * chunkSize;\n    const end = start + chunkSize >= blob.size ? blob.size : start + chunkSize;\n    r.readAsArrayBuffer(blobSlice.call(blob, start, end));\n  }\n  loadNext();\n  return state;\n}\n\ninterface Action {\n  type: string;\n  payload: any;\n}\n\ninterface Downloading extends Action {\n  type: \"downloading\";\n  payload: { now: number; size: number };\n}\n\ninterface Downloaded extends Action {\n  type: \"downloaded\";\n  payload: { chunks: ArrayBuffer[]; name: string };\n}\n\ntype Actions = Downloading | Downloaded;\n\nexport default class FileShare {\n  subject = new Subject<Actions>();\n  state = this.subject.asObservable();\n\n  private chunks: ArrayBuffer[] = [];\n  public name: string = \"\";\n  private size: number = 0;\n\n  constructor(private peer: WebRTC, public label?: string) {\n    if (!label) label = \"file\";\n    console.log({ label });\n    peer.onData.subscribe(raw => {\n      const { label, data } = raw;\n      if (label === this.label) {\n        try {\n          const obj = JSON.parse(data);\n          switch (obj.state) {\n            case \"start\":\n              this.chunks = [];\n              this.name = obj.name;\n              this.size = obj.size;\n              break;\n            case \"end\":\n              this.subject.next({\n                type: \"downloaded\",\n                payload: { chunks: this.chunks, name: this.name }\n              } as Downloaded);\n              peer.send(\n                JSON.stringify({ state: \"complete\", name: this.name }),\n                this.label\n              );\n              this.chunks = [];\n              this.name = \"\";\n              break;\n          }\n        } catch (error) {\n          this.chunks.push(data);\n          this.subject.next({\n            type: \"downloading\",\n            payload: { now: this.chunks.length * chunkSize, size: this.size }\n          } as Downloading);\n        }\n      }\n    });\n  }\n\n  sendStart(name: string, size: number) {\n    this.name = name;\n    this.peer.send(JSON.stringify({ state: \"start\", size, name }), this.label);\n  }\n\n  sendChunk(chunk: ArrayBuffer) {\n    this.peer.send(chunk, this.label);\n  }\n\n  sendEnd() {\n    this.peer.send(JSON.stringify({ state: \"end\" }), this.label);\n  }\n\n  send(blob: File) {\n    this.sendStart(blob.name, blob.size);\n    getSliceArrayBuffer(blob).subscribe(\n      chunk => this.sendChunk(chunk),\n      () => {},\n      () => {\n        this.sendEnd();\n      }\n    );\n  }\n}\n"]}